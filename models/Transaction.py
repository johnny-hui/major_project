import io
import pickle
from base64 import b64encode
from datetime import datetime, timedelta
from PIL import Image
from tinyec.ec import Point
from utility.constants import TRANSACTION_TO_STRING, TRANSACTION_EXPIRY_TIME, TRANSACTION_MAX_IMG_SIZE, TIMESTAMP_FORMAT
from utility.crypto.ec_keys_utils import create_signature, verify_signature, compress_pub_key, compress_signature


class Transaction:
    """A class representing a Block Transaction
    (i.e., Network Connection Request)
    """
    def __init__(self, ip: str, port: int, first_name: str,
                 last_name: str, public_key: Point):
        """
        A constructor for a Transaction object.

        @param ip:
            A string for the IP address

        @param port:
            A string for the port number

        @param first_name:
            A string for the first name

        @param last_name:
            A string for the last name

        @param public_key:
            A point (x, y) on an elliptic curve
        """
        self.ip_addr = ip
        self.port = port
        self.role = None
        self.pub_key = public_key
        self.first_name = first_name
        self.last_name = last_name
        self.image = None
        self.timestamp = None
        self.signature = None
        self.received_by = None

    def sign_transaction(self, pvt_key: int):
        """
        Signs the transaction using a private key.

        @param pvt_key:
            A random integer generated by the Node

        @return: None
        """
        # Get data to be signed (dictionary)
        data = {
            'ip_addr': self.ip_addr,
            'port': self.port,
            'role': self.role,
            'pub_key': self.pub_key,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'image': b64encode(self.image).decode(),
            'timestamp': self.timestamp,
        }

        # Preprocess the data by serialization
        serialized_data = pickle.dumps(data)

        # Sign the data
        self.signature = create_signature(pvt_key, data=serialized_data)

    def is_verified(self):
        """
        Verifies the Transaction object.

        @return: Boolean (T/F)
            True if signature is valid, False otherwise
        """
        # Get data to be signed (dictionary)
        data = {
            'ip_addr': self.ip_addr,
            'port': self.port,
            'role': self.role,
            'pub_key': self.pub_key,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'image': b64encode(self.image).decode(),
            'timestamp': self.timestamp,
        }

        # Preprocess the data by serialization
        serialized_data = pickle.dumps(data)

        # Verify the signature
        if verify_signature(pub_key=self.pub_key, signature=self.signature, data=serialized_data):
            return True
        else:
            return False

    def is_expired(self):
        """
        Checks if the transaction object has expired based off of
        current system time (max time before expiry is set to 5 minutes).

        @return: Boolean (T/F)
            True if expired; False otherwise
        """
        timestamp = datetime.strptime(self.timestamp, TIMESTAMP_FORMAT) + timedelta(minutes=3)
        current_time = datetime.now()

        time_remaining = int((timestamp - current_time).total_seconds())

        if time_remaining <= 0:
            print(f"[+] CONNECTION REQUEST EXPIRED: A transaction from (IP: {self.ip_addr}) has exceeded max "
                  f"{TRANSACTION_EXPIRY_TIME} seconds.")
            return True
        else:
            return False

    def get_time_remaining(self):
        """
        Gets the current time (at invocation) and
        determines the remaining time (in seconds)
        before expiry.

        @return: time_remaining or None
            time_remaining (in seconds) if positive; None otherwise
        """
        timestamp = datetime.strptime(self.timestamp, TIMESTAMP_FORMAT) + timedelta(minutes=3)
        current_time = datetime.now()

        time_remaining = int((timestamp - current_time).total_seconds())

        if time_remaining <= 0:
            return None
        else:
            return time_remaining

    def show_image(self):
        """Shows the image attached to the transaction."""
        Image.open(io.BytesIO(self.image)).show()

    def set_image(self, image_bytes: bytes):
        """
        Set the image attribute

        @raise ValueError:
            The required image must be larger than 1 MB in size

        @return: None
        """
        if len(image_bytes) < TRANSACTION_MAX_IMG_SIZE:
            raise ValueError(f"[+] ERROR: The provided image is less than 1 MB ({len(image_bytes)}); "
                             f"please provide a larger image!")
        else:
            self.image = image_bytes

    def set_timestamp(self, timestamp: str):
        """
        Set the timestamp attribute
        @return: None
        """
        self.timestamp = timestamp

    def set_signature(self, signature: bytes):
        """
        Set the signature attribute
        @return: None
        """
        self.signature = signature

    def set_role(self, status: str):
        """
        Set the role attribute
        @return: None
        """
        self.role = status

    def set_received_by(self, ip: str):
        """
        Set the received_by attribute
        @return: None
        """
        self.received_by = ip

    def __str__(self):
        """
        Returns the string representation of the
        Transaction object.
        @return: None
        """
        hashed_pub_key = compress_pub_key(self.pub_key)
        hashed_signature = compress_signature(self.signature)
        return (TRANSACTION_TO_STRING.format(self.ip_addr, self.port, self.role, hashed_pub_key, self.first_name,
                                             self.last_name, self.timestamp, hashed_signature, self.received_by))
