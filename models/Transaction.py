import io
import pickle
from base64 import b64encode
from datetime import datetime, timedelta
from PIL import Image
from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey, EllipticCurvePrivateKey
from utility.crypto.ec_keys_utils import create_signature, verify_signature, compress_public_key, compress_signature, \
    public_key_to_string, load_public_key_from_string
from utility.general.constants import TRANSACTION_TO_STRING, TRANSACTION_EXPIRY_TIME_SECONDS, TRANSACTION_MAX_IMG_SIZE, \
    TIMESTAMP_FORMAT, TRANSACTION_EXPIRY_TIME_MINUTES


class Transaction:
    """A class representing a Block Transaction
    (i.e., Network Connection Request)
    """
    def __init__(self, ip: str, port: int, first_name: str,
                 last_name: str, public_key: EllipticCurvePublicKey):
        """
        A constructor for a Transaction object.

        @param ip:
            A string for the IP address

        @param port:
            A string for the port number

        @param first_name:
            A string for the first name

        @param last_name:
            A string for the last name

        @param public_key:
            A point (x, y) on an elliptic curve
        """
        self.ip_addr = ip
        self.port = port
        self.role = None
        self.pub_key = public_key_to_string(public_key)  # => saved as string for pickle (serialization)
        self.first_name = first_name
        self.last_name = last_name
        self.image = None
        self.timestamp = None
        self.signature = None
        self.received_by = None

    def sign_transaction(self, pvt_key: EllipticCurvePrivateKey):
        """
        Signs the transaction using a private key.

        @param pvt_key:
            A random integer generated by the Node

        @return: None
        """
        # Get data to be signed (dictionary)
        data = {
            'ip_addr': self.ip_addr,
            'port': self.port,
            'role': self.role,
            'pub_key': self.pub_key,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'image': b64encode(self.image).decode(),
            'timestamp': self.timestamp,
        }

        # Preprocess the data by serialization
        serialized_data = pickle.dumps(data)

        # Sign the data
        self.signature = create_signature(pvt_key, data=serialized_data)

    def is_verified(self):
        """
        Verifies the Transaction object.

        @return: Boolean (T/F)
            True if signature is valid, False otherwise
        """
        # Get data to be signed (dictionary)
        data = {
            'ip_addr': self.ip_addr,
            'port': self.port,
            'role': self.role,
            'pub_key': self.pub_key,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'image': b64encode(self.image).decode(),
            'timestamp': self.timestamp,
        }

        # Preprocess the data by serialization
        serialized_data = pickle.dumps(data)

        # Load the public key from Transaction
        pub_key = load_public_key_from_string(self.pub_key)

        # Verify the signature
        if verify_signature(pub_key=pub_key, signature=self.signature, data=serialized_data):
            return True
        else:
            return False

    def is_expired(self):
        """
        Checks if the transaction object has expired based off of
        current system time (max time before expiry is set to 5 minutes).

        @return: Boolean (T/F)
            True if expired; False otherwise
        """
        timestamp = datetime.strptime(self.timestamp, TIMESTAMP_FORMAT) + timedelta(minutes=TRANSACTION_EXPIRY_TIME_MINUTES)
        current_time = datetime.now()

        time_remaining = int((timestamp - current_time).total_seconds())

        if time_remaining <= 0:
            print(f"[+] CONNECTION REQUEST EXPIRED: A transaction from (IP: {self.ip_addr}) has exceeded max "
                  f"{TRANSACTION_EXPIRY_TIME_SECONDS} seconds.")
            return True
        else:
            return False

    def get_time_remaining(self):
        """
        Gets the current time (at invocation) and
        determines the remaining time (in seconds)
        before expiry.

        @return: time_remaining or None
            The time remaining (in seconds); None otherwise
        """
        timestamp = datetime.strptime(self.timestamp, TIMESTAMP_FORMAT) + timedelta(minutes=TRANSACTION_EXPIRY_TIME_MINUTES)
        current_time = datetime.now()

        time_remaining = int((timestamp - current_time).total_seconds())

        if time_remaining <= 0:
            return None
        else:
            return time_remaining

    def is_near_expiry(self, buffer_time: int):
        """
        Checks if the Transaction object is near expiry based on a
        buffer time (in seconds).

        @param buffer_time:
            An integer representing the buffer time

        @return: Boolean (T/F)
            True, False otherwise
        """
        time_remaining = self.get_time_remaining()
        if time_remaining:
            return time_remaining < buffer_time
        else:  # => if expired
            return True


    def show_image(self):
        """Shows the image attached to the transaction."""
        Image.open(io.BytesIO(self.image)).show()

    def set_image(self, image_bytes: bytes):
        """
        Set the image attribute

        @raise ValueError:
            The required image must be larger than 1 MB in size

        @return: None
        """
        if len(image_bytes) < TRANSACTION_MAX_IMG_SIZE:
            raise ValueError(f"[+] ERROR: The provided image is less than 1 MB ({len(image_bytes)}); "
                             f"please provide a larger image!")
        else:
            self.image = image_bytes

    def set_timestamp(self, timestamp: str):
        """
        Set the timestamp attribute
        @return: None
        """
        self.timestamp = timestamp

    def set_signature(self, signature: bytes):
        """
        Set the signature attribute
        @return: None
        """
        self.signature = signature

    def set_role(self, status: str):
        """
        Set the role attribute
        @return: None
        """
        self.role = status

    def set_received_by(self, ip: str):
        """
        Set the received_by attribute
        @return: None
        """
        self.received_by = ip

    def __str__(self):
        """
        Returns the string representation of the Transaction object.

        @attention Override:
            This function overrides the default toString() for object class

        @return: None
        """
        pub_key = load_public_key_from_string(self.pub_key)
        hashed_pub_key = compress_public_key(pub_key)
        hashed_signature = compress_signature(self.signature)
        return (TRANSACTION_TO_STRING.format(self.ip_addr, self.port, self.role, hashed_pub_key, self.first_name,
                                             self.last_name, self.timestamp, hashed_signature, self.received_by))
