import select
import sys
import threading
from utility.cipher_utils import get_user_menu_option
from utility.constants import NODE_INIT_MSG, NODE_INIT_SUCCESS_MSG, USER_INPUT_THREAD_NAME, USER_INPUT_START_MSG, \
    INPUT_PROMPT, MIN_MENU_ITEM_VALUE, MAX_MENU_ITEM_VALUE, SELECT_CLIENT_SEND_MSG_PROMPT, \
    USER_MENU_THREAD_TERMINATE, ROLE_PEER
from utility.ec_keys_utils import generate_keys
from utility.node_init import parse_arguments, initialize_socket, get_application_timestamp
from utility.node_utils import display_menu, view_current_connections, close_application, send_message, \
    get_specific_peer


class Node:
    """
    A class representing a P2P Node.

    Attributes:
        ip - The ip address
        port - The port number
        name - The name of the Node
        role - The role of the Node (default=PEER)
        own_socket - The socket object for the Node
        pvt_key - The private key generated by ECDH (via. brainpoolP256r1)
        pub_key - The public key generated by ECDH (via. brainpoolP256r1)
        fd_list - A list of file descriptors to monitor (using select() function)
        peer_dict - A dictionary containing information about each connected peer {IP: (name, shared secret key, IV)}
        is_connected - A boolean flag indicating whether the Node is connected
        terminate - A boolean flag that determines if the server should terminate
    """
    def __init__(self):
        print(NODE_INIT_MSG)
        self.name, self.ip, self.port = parse_arguments()
        self.role = ROLE_PEER
        self.own_socket = initialize_socket(self.ip, self.port)
        self.pvt_key, self.pub_key = generate_keys()
        self.fd_list = [self.own_socket]  # => Monitored by select()
        self.peer_dict = {}  # Format {IP: [name, shared_secret, IV, cipher mode]}
        self.pendingTransactions = []
        self.app_timestamp = get_application_timestamp()
        self.is_connected = False
        self.terminate = False
        print(NODE_INIT_SUCCESS_MSG)

    def start(self):
        self.__start_user_menu_thread()

    def __start_user_menu_thread(self):
        """
        Starts a thread for handling user input
        for the menu.

        @return: None
        """
        input_thread = threading.Thread(target=self._menu, name=USER_INPUT_THREAD_NAME)
        input_thread.start()
        print(USER_INPUT_START_MSG)

    def _menu(self):
        """
        Displays the menu and handles user input
        using stdin and select().

        @return: None
        """
        inputs = [sys.stdin]
        print("=" * 80)
        display_menu(role=self.role, is_connected=self.is_connected)
        print(INPUT_PROMPT)

        while not self.terminate:
            readable, _, _ = select.select(inputs, [], [])

            # Get User Command from the Menu and perform the task
            for fd in readable:
                if fd == sys.stdin:
                    command = get_user_menu_option(fd, MIN_MENU_ITEM_VALUE, MAX_MENU_ITEM_VALUE)
                    self._handle_command(command)

    def _handle_command(self, command: int):
        """
        Handles and performs user menu command options
        for the Server.

        @param command:
            An integer representing the menu option
            to be performed

        @return: None
        """
        def send_message_to_specific_peer():
            client_sock, cipher, _, _ = get_specific_peer(self, prompt=SELECT_CLIENT_SEND_MSG_PROMPT)
            send_message(client_sock, cipher)

        def terminate_application():
            close_application(self)
            print(USER_MENU_THREAD_TERMINATE)

        def perform_post_action_steps():
            if command == 6:  # If terminate application, don't print the menu again
                return None
            display_menu(role=self.role, is_connected=self.is_connected)
            print(INPUT_PROMPT)

        # Define Actions
        actions_when_not_connected = {
            1: lambda: None,
            2: lambda: None,
            3: lambda: None,
            4: lambda: None,
            5: lambda: view_current_connections(self),
            6: lambda: terminate_application()
        }
        actions_when_connected = {
            1: lambda: send_message_to_specific_peer(),
            2: lambda: None,
            3: lambda: None,
            4: lambda: None,
            5: lambda: view_current_connections(self),
            6: lambda: terminate_application(),
        }

        # Grab action
        if self.is_connected and len(self.fd_list) > 1:
            action = actions_when_connected.get(command)
        else:
            action = actions_when_not_connected.get(command)

        # Perform action
        if action:
            action()
            perform_post_action_steps()
