from models.Node import Node
from utility.client_server.client_server import connect_to_P2P_network
from utility.general.constants import ROLE_ADMIN, INPUT_PROMPT, STATUS_APPROVED, BROADCAST_MESSAGE_PROMPT
from utility.general.utils import start_parallel_operation
from utility.node.delegate_utils import initiate_consensus
from utility.node.node_utils import display_menu, approve_connection_request, \
    revoke_connection_request, view_pending_connection_requests, view_current_peers, close_application, \
    send_message_to_specific_peer, send_message


class AdminNode(Node):
    """
    A class representing an Admin Node.

    Attributes:
        ip - The ip address
        port - The port number
        name - The name of the Node
        role - The role of the Node (default=ADMIN)
        own_socket - The socket object for the Node
        pvt_key - The private key generated by ECDH (via. brainpoolP256r1)
        pub_key - The public key generated by ECDH (via. brainpoolP256r1)
        fd_list - A list of file descriptors to monitor (using select() function)
        peer_dict - A dictionary containing information about each connected peer {IP: (name, shared secret key, IV)}
        is_connected - A boolean flag indicating whether the Node is connected
        terminate - A boolean flag that determines if the server should terminate
    """
    def __init__(self):
        super().__init__()
        self.role = ROLE_ADMIN

    def _handle_command(self, command: int, max_menu_value: int):
        """
        An override function that handles and performs user
        menu command options (as a Delegate).

        @param command:
            An integer representing the menu option
            to be performed

        @return: None
        """

        def broadcast_message():
            """
            Broadcasts a message to all connected peers.
            @return: None
            """
            peer_params_list = []
            message = input(f"[+] Enter a message to send to broadcast: ")

            for ip, peer in self.peer_dict.items():
                if peer.status == STATUS_APPROVED:
                    peer_params_list.append((peer.socket, peer.secret, peer.iv, peer.mode, message))

            start_parallel_operation(task=send_message,
                                     task_args=peer_params_list,
                                     num_processes=len(peer_params_list),
                                     prompt=BROADCAST_MESSAGE_PROMPT)

        def perform_post_action_steps():
            actions_list = actions_when_connected if self.is_connected else actions_when_not_connected
            if command == len(actions_list):
                return None
            display_menu(role=self.role, is_connected=self.is_connected)
            print(INPUT_PROMPT)

        # ===============================================================================================

        # Define Actions
        actions_when_not_connected = {
            1: lambda: connect_to_P2P_network(self),
            2: lambda: approve_connection_request(self),
            3: lambda: revoke_connection_request(self),
            4: lambda: None,
            5: lambda: view_pending_connection_requests(self),
            6: lambda: view_current_peers(self),
            7: lambda: close_application(self)

        }
        actions_when_connected = {
            1: lambda: send_message_to_specific_peer(self),
            2: lambda: broadcast_message(),
            3: lambda: initiate_consensus(self),
            4: lambda: revoke_connection_request(self),
            5: lambda: None,
            6: lambda: view_pending_connection_requests(self),
            7: lambda: view_current_peers(self),
            8: lambda: print("[+] Promote a Peer"),
            9: lambda: print("[+] Kick a Peer"),
            10:lambda: close_application(self)
        }

        # Grab action
        if self.is_connected and len(self.fd_list) > 1:
            action = actions_when_connected.get(command)
        else:
            action = actions_when_not_connected.get(command)

        # Perform action
        if action:
            action()
            perform_post_action_steps()
