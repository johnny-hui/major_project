from models.Node import Node
from utility.blockchain.utils import view_blockchain
from utility.client_server.client_server import connect_to_P2P_network
from utility.general.constants import ROLE_ADMIN, INPUT_PROMPT, STATUS_APPROVED, BROADCAST_MESSAGE_PROMPT, \
    MAX_MENU_ITEM_VALUE
from utility.general.utils import start_parallel_operation
from utility.node.admin_utils import promote_peer, kick_peer
from utility.node.delegate_utils import initiate_consensus
from utility.node.node_utils import display_menu, approve_connection_request, \
    revoke_connection_request, view_pending_connection_requests, view_current_peers, close_application, \
    send_message_to_specific_peer, send_message


class AdminNode(Node):
    """
    A class representing an Admin Node.

    Attributes:
        ip - The ip address
        port - The port number (default=323)
        name - The name of the Node
        role - The role of the Node (default=PEER)
        mode - A string for the encryption mode (default=ECB)
        own_socket - The socket object for the Node
        pvt_key - The private key generated by ECDH (via. brainpoolP256r1)
        pub_key - The public key generated by ECDH (via. brainpoolP256r1)
        fd_list - A list of file descriptors to monitor (using select() function)
        fd_pending - A list that stores sockets of pending peers awaiting consensus
        peer_dict - A dictionary containing information about each connected peer
        pending_transactions - A list containing pending Transaction objects of requesting peers
        app_timestamp - A string containing the timestamp (from NTP Server) of when the Node application was started
        is_connected - A boolean flag indicating whether the Node is connected
        is_promoted - A boolean flag indicating whether the Node is promoted to DelegateNode
        terminate - A boolean flag that determines if the server should terminate
        consensus_event - A threading Event object that is used to communicate with main thread when consensus starts/ends
    """
    def __init__(self):
        super().__init__()
        self.role = ROLE_ADMIN

    def _handle_command(self, command: int, max_menu_value: int):
        """
        An override function that handles and performs user
        menu command options (as a Delegate).

        @param command:
            An integer representing the menu option
            to be performed

        @return: None
        """
        def broadcast_message():
            """
            Broadcasts a message to all connected peers.
            @return: None
            """
            peer_params_list = []
            message = input(f"[+] Enter a message to send to broadcast: ")

            for ip, peer in self.peer_dict.items():
                if peer.status == STATUS_APPROVED:
                    peer_params_list.append((peer.socket, peer.secret, peer.iv, peer.mode, message))

            start_parallel_operation(task=send_message,
                                     task_args=peer_params_list,
                                     num_processes=len(peer_params_list),
                                     prompt=BROADCAST_MESSAGE_PROMPT)

        def perform_post_action_steps():
            if not self.is_connected and command == MAX_MENU_ITEM_VALUE:
                return None
            if command == max_menu_value:
                return None
            display_menu(role=self.role, is_connected=self.is_connected)
            print(INPUT_PROMPT)
        # ===============================================================================================

        # Define Actions
        actions_when_not_connected = {
            1: lambda: connect_to_P2P_network(self),
            2: lambda: approve_connection_request(self),
            3: lambda: revoke_connection_request(self),
            4: lambda: view_blockchain(self),
            5: lambda: view_pending_connection_requests(self),
            6: lambda: view_current_peers(self),
            7: lambda: close_application(self)
        }
        actions_when_connected = {
            1: lambda: send_message_to_specific_peer(self),
            2: lambda: broadcast_message(),
            3: lambda: initiate_consensus(self),
            4: lambda: revoke_connection_request(self),
            5: lambda: view_blockchain(self),
            6: lambda: view_pending_connection_requests(self),
            7: lambda: view_current_peers(self),
            8: lambda: promote_peer(self),
            9: lambda: kick_peer(self),
            10:lambda: close_application(self)
        }

        # Grab action
        if self.is_connected and len(self.fd_list) > 1:
            action = actions_when_connected.get(command)
        else:
            action = actions_when_not_connected.get(command)

        # Perform action
        if action:
            action()
            perform_post_action_steps()
