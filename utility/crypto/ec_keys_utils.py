"""
Description:
This Python file contains functions that assist in creating
and managing EC (elliptic curve) keys.

"""
import hashlib
import secrets
from hashlib import sha3_256
from tinyec import registry
from tinyec.ec import Point
from utility.constants import BLOCK_SIZE

# CONSTANTS
BRAINPOOLP256r1 = "brainpoolP256r1"


def compress_pub_key(key: Point):
    """
    Compresses a key generated by ECDH key
    exchange protocol into a hex representation
    of 65 hex digits.

    @param key:
        The key to be compressed

    @return: Compressed Key
        A compressed key represented as a hex string
    """
    return hex(key.x) + hex(key.y % 2)[2:]


def compress_signature(signature: tuple):
    """
    Compresses the signature tuple (r, s) into a
    printable format.

    @param signature:
        A tuple containing a pair of integers (r,s)

    @return: signature_hash
        A string containing the hash of the signature
    """
    r, s = signature
    return hex(r), hex(s)


def compress_shared_secret(secret: bytes):
    """
    Compresses the shared secret.

    @param secret:
        Bytes containing the shared secret

    @return: secret.hex()
        Hex representation of the shared secret
    """
    return secret.hex()


def compress_iv(iv: bytes | None):
    """
    Compresses an initialization factor (IV).

    @param iv:
        Bytes of the initialization factor

    @return: iv.hex() | None
        Hex representation of the shared secret
    """
    if iv:
        return iv.hex()
    return None


def hash_data(data: bytes | None):
    """
    Utilizes SHA3-256 to hash any given data.

    @param data:
        Bytes containing the data to be hashed

    @return: hasher.hexdigest()
        A string containing the hashed data
    """
    if data:
        hasher = hashlib.sha3_256()
        hasher.update(data)
        return hasher.hexdigest()
    return None


def derive_shared_secret(pvt_key: int, pub_key):
    """
    Derives the shared secret between a private key
    and another host's public key by performing ECC point
    multiplication.

    @param pvt_key:
        An owning host's private key

    @param pub_key:
        The other host's public key

    @return: shared_secret
        A 16-byte shared key derived from the 'brainpoolP256r1'
        elliptic curve and then hashed using SHA3-256.
    """
    # EC point multiplication with private and public key
    shared_key = pvt_key * pub_key

    # Use the X-coordinate of the shared key (point on an elliptic curve) and convert to bytes
    shared_key_bytes = shared_key.x.to_bytes((shared_key.x.bit_length() + 7) // 8, 'big')

    # Compress the key by taking only the first 16-bytes of the SHA256 hash
    shared_key_hash = sha3_256(shared_key_bytes).digest()
    return shared_key_hash[:BLOCK_SIZE]


def generate_keys():
    """
    Generates a public/private key pair using
    the brainpoolP256r1 elliptic curve.

    @return: private_key, public_key
    """
    # Define BrainPool 256-bit Elliptic Curve
    curve = registry.get_curve('brainpoolP256r1')

    # Generate Private Key (a random int from [1, n-1])
    private_key = secrets.randbelow(curve.field.n)

    # Generate Public Key (a * G)
    public_key = private_key * curve.g
    print("[+] ECDH Private/Public Key pairs have been successfully generated!")

    print(f"[+] Your private key: {hex(private_key)}")
    print(f"[+] Your public key: {compress_pub_key(public_key)}")

    return private_key, public_key


def create_signature(pvt_key: int, data: bytes):
    """
    Creates a signature using a simplified version of ECDSA
    (Elliptic Curve Digital Signature Algorithm) based on
    ElGamal's signature scheme.

    @note Information Source:
        https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages

    @param pvt_key:
        A random integer selected within 'brainpoolP256r1'
        elliptic curve's field

    @param data:
        The data to be signed (in bytes)

    @return: signature (r,s)
        A tuple containing a pair of integers (r,s)
    """
    # Define BrainPool 256-bit Elliptic Curve
    curve = registry.get_curve(BRAINPOOLP256r1)

    # Hash the data and convert it to integer
    data_hash = sha3_256(data).digest()
    e = int.from_bytes(data_hash, byteorder='big')

    # Generate a random integer k
    k = secrets.randbelow(curve.field.n)

    # Calculate the random curve point (R) and its x-coordinate (r)
    R = k * curve.g
    r = R.x % curve.field.n

    # Calculate the signature proof s
    s = ((e + r * pvt_key) * pow(k, -1, curve.field.n)) % curve.field.n

    # Return the signature (pair of integers r, s)
    return (r, s)


def verify_signature(signature: tuple, data: bytes, pub_key: Point):
    """
    Verifies a signature created by the ECDSA algorithm.

    @note Information Source:
        https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages

    @param signature:
        A tuple containing a pair of integers (r,s)

    @param data:
        The data to be verified (in bytes)

    @param pub_key:
        A point (x, y) on the elliptic curve

    @return: Boolean (T/F)
        True if the signature is valid, False otherwise
    """
    # Define BrainPool 256-bit Elliptic Curve
    curve = registry.get_curve(BRAINPOOLP256r1)

    # Unpack the r, s values of signature
    r, s = signature

    # Check if r and s are within galois field of the elliptic curve
    if not (1 <= r <= curve.field.n - 1) or not (1 <= s <= curve.field.n - 1):
        return False

    # Hash the data and convert it to integer
    data_hash = sha3_256(data).digest()
    e = int.from_bytes(data_hash, byteorder='big')

    # Calculate the modular inverse w, and intermediate values u1, u2
    w = pow(s, -1, curve.field.n)
    u1 = (e * w) % curve.field.n
    u2 = (r * w) % curve.field.n

    # Determine the curve point (R) and validate with signature point r
    R = u1 * curve.g + u2 * pub_key
    return R.x % curve.field.n == r


def generate_shared_secret():
    """
    Generates a random shared secret key using ECDH key exchange
    and the 'brainpoolP256r1' elliptic curve.

    @attention Use Case:
        Only used by CipherPlayground class (for generation of
        main key and avalanche effect analysis SKAC in Cipher
        Playground)

    @return: hash_object[:block_size]
        A hash of the shared secret (according to a block size)
    """
    print("[+] GENERATING SHARED EC KEY: Now generating an elliptic curve shared key...")
    pvt_key_1, pub_key_1 = generate_keys()
    pvt_key_2, pub_key_2 = generate_keys()
    shared_secret = derive_shared_secret(pvt_key_1, pub_key_2)
    print(f"[+] OPERATION SUCCESSFUL: The main key for cipher playground is {shared_secret.hex()}")
    return shared_secret
